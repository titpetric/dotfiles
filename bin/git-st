#!/usr/bin/env bash
# git-st â€” the ultimate clean/dirty multi-repo status viewer

RED='\033[0;31m' GREEN='\033[0;32m' YELLOW='\033[1;33m' BLUE='\033[0;34m' CYAN='\033[0;36m' NC='\033[0m'

check_repo() {
  local dir="$1"
  local name="${dir#./}"
  [[ "$name" == "." ]] && name="."

  printf "${CYAN}Repository:${NC} ${BLUE}%s${NC}" "$name"
  cd "$dir" || return

  # Count unpushed commits (silently fail if no upstream)
  unpushed=$(git rev-list --count @{u}.. 2>/dev/null || echo 0)

  # Use only --porcelain=v1 for reliable empty check
  changes=$(git status --porcelain=v1)

  if (( unpushed == 0 )) && [[ -z "$changes" ]]; then
    printf "  ${GREEN}Clean${NC}\n"
  else
    (( unpushed > 0 )) && printf "  ${RED}Unpushed: %d${NC}\n" "$unpushed"
    [[ -n "$changes" ]] && {
      printf "  ${YELLOW}Changes:${NC}\n"
      printf "%b\n" "$changes" | while IFS= read -r line; do
        code="${line:0:2}" file="${line:3}"
        case "$code" in
          "M ")  printf "    ${YELLOW}M${NC} %s\n" "$file" ;;
          "A ")  printf "    ${GREEN}A${NC} %s\n" "$file" ;;
          "D ")  printf "    ${RED}D${NC} %s\n" "$file" ;;
          "R ")  printf "    ${YELLOW}R${NC} %s\n" "$file" ;;
          "C ")  printf "    ${GREEN}C${NC} %s\n" "$file" ;;
          "??" ) printf "    ${RED}?${NC} %s\n" "$file" ;;
          *)     printf "    ${YELLOW}%s${NC} %s\n" "$code" "$file" ;;
        esac
      done
    }
  fi
}

export -f check_repo
export RED GREEN YELLOW BLUE CYAN NC

# Fast, parallel, correct path handling
find . \( -path '*/vendor/*' -o -path '*/node_modules/*' -o -path '*/.git/*' \) -prune -o \
  -type d -name '.git' -print 2>/dev/null |
  xargs -n1 -P12 dirname |
  xargs -I{} bash -c 'check_repo "{}"'
